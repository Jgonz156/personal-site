import { DisplayMath, InlineMath } from "@/components/math"
import {
  LectureNotes,
  LectureResources,
} from "@/components/lecture-sections"
import { QuestionBox } from "@/components/question-box"
import { DefinitionBox } from "@/components/interactive-example"

## Recap

Last time we completed our toolkit of **set operations** â€” union, intersection, set difference, complement, symmetric difference, powerset, and Cartesian product. We discovered the **logic-set bridge**: every set operation corresponds to a logical connective, and we can borrow logical proofs to establish set properties like commutativity, associativity, and De Morgan's Laws.

We also connected powersets and Cartesian products to type theory: sets inhabit powersets, tuples inhabit Cartesian products â€” set operations define the types that collections inhabit.

---

## Today's Agenda

We've built up a rich toolkit of operators on logic, numbers, and collections. Today we step back and ask a deeper question: what can our operators tell us about the **nature** of the things they compare?

- **The Grand Operator Recap** â€” Everything we've built so far
- **Boolean Operators Are Special** â€” Relations test relationships
- **The Existential Quantifier** â€” "There exists an x such that..."
- **The Universal Quantifier** â€” "For all x..."
- **Quantifier Duality** â€” Proving and disproving quantified statements
- **Relational Properties** â€” Reflexivity, symmetry, antisymmetry, transitivity, totality
- **Equivalence Relations** â€” What makes things "equal"
- **Partial and Total Orders** â€” What makes things "orderable"
- **Relations in Python** â€” Dunder methods, sorting contracts, and hashability

---

## The Grand Operator Recap

Let's take stock of everything we've learned. Here is every operator we've explored, organized by domain:

### Logic Operators

| Operator | Type Signature |
| :--- | :--- |
| Logical equivalence ($\equiv$) | (Bool, Bool) $\to$ Bool |
| Conjunction ($\land$) | (Bool, Bool) $\to$ Bool |
| Disjunction ($\lor$) | (Bool, Bool) $\to$ Bool |
| Implication ($\to$) | (Bool, Bool) $\to$ Bool |
| Negation ($\lnot$) | Bool $\to$ Bool |

### Numeric Operators

| Operator | Type Signature |
| :--- | :--- |
| Addition ($+$) | (Num, Num) $\to$ Num |
| Subtraction ($-$) | (Num, Num) $\to$ Num |
| Multiplication ($\times$) | (Num, Num) $\to$ Num |
| Division ($\div$) | (Num, Num) $\to$ Rational |
| Exponentiation | (Num, Num) $\to$ Num |
| Mod | (Int, Int) $\to$ Int |
| Divides ($\mid$) | (Int, Int) $\to$ **Bool** |
| Congruence ($\equiv$) | (Int, Int) $\to$ **Bool** |
| Less than ($\lt$) | (Num, Num) $\to$ **Bool** |
| Less/equal ($\leq$) | (Num, Num) $\to$ **Bool** |
| Greater than ($\gt$) | (Num, Num) $\to$ **Bool** |
| Greater/equal ($\geq$) | (Num, Num) $\to$ **Bool** |

### Collection Operators

| Operator | Type Signature |
| :--- | :--- |
| Tuple concatenation ($\cdot$) | (Tuple, Tuple) $\to$ Tuple |
| Indexing ($\downarrow$) | (Tuple, Nat) $\to$ Item |
| Membership ($\in$) | (T, Set) $\to$ **Bool** |
| Subset ($\subseteq$) | (Set, Set) $\to$ **Bool** |
| Proper subset ($\subset$) | (Set, Set) $\to$ **Bool** |
| Superset ($\supseteq$) | (Set, Set) $\to$ **Bool** |
| Proper superset ($\supset$) | (Set, Set) $\to$ **Bool** |
| Union ($\cup$) | (Set, Set) $\to$ Set |
| Intersection ($\cap$) | (Set, Set) $\to$ Set |
| Set difference ($\setminus$) | (Set, Set) $\to$ Set |
| Complement | Set $\to$ Set |
| Symmetric diff ($\triangle$) | (Set, Set) $\to$ Set |
| Cartesian product ($\times$) | (Set, Set) $\to$ Set |
| Cardinality | Set $\to$ Nat |
| Powerset | Set $\to$ Set |

That's a lot of operators! With these tools alone, all of the mathematics we've discovered so far can be encoded â€” with the asterisk that the knowledge we've acquired is still debated, and more is being discovered every day.

But now it's time to explore the tools we already have at a higher level. We've already seen **algebraic properties** like commutativity, associativity, and distributivity that describe how operators interact with their inputs, outputs, and each other. Today we discover another set of properties â€” ones that apply to a specific *kind* of operator.

---

## Boolean Operators Are Special

Look back at those tables. Do you notice something about the operators in **bold**?

Every operator that returns a **Bool** answers a yes-or-no question. It doesn't produce a new number, set, or tuple â€” it tests whether a *relationship* holds between its inputs.

Think about it:
- **Have you ever decided whether one program is better than another?** You became an operator that took two programs as input and returned yes or no â€” confirming the existence of a relationship between those programs.
- **Have you ever compared heights?** You were testing the "taller than" relationship between two people.
- **Conjunction** tests whether things are happening together. **Logical equivalence** tests whether two things carry the same information. **Less than** tests whether one number precedes another.

These operators don't just compute â€” they **sort the world** into things that have some property and things that don't.

<DefinitionBox term="Relation">

A **relation** on a set $A$ is an operation whose output type is Bool:

<DisplayMath formula="R : (A, A) \to \text{Bool}" />

It tests whether a relationship holds between its inputs. If $R(a, b) = T$, we say $a$ is **related to** $b$ under $R$.

</DefinitionBox>

The set of all pairs where $R$ returns true can be collected into a set:

<DisplayMath formula="R = \{(a, b) \in A \times A \mid R(a, b) = T\}" />

That's a **set of tuples** â€” our two collection types working together once again! A relation is formally a subset of the Cartesian product.

> **ðŸ“Œ Key Insight:** Only operators that return Bool can be interpreted as testing relationships. Addition returns a number â€” it's not testing anything. Union returns a set â€” also not testing. But $\leq$ returns Bool â€” it's testing whether one number is at most another. If it returns a Bool, it's a relation.

Look back at the operator tables and identify every boolean-returning operator. For each one, ask yourself: what relationship is it testing?

---

## The Existential Quantifier

Before we can formally define the properties of relations, we need to upgrade our logical toolkit with two powerful new pieces.

The first is the **existential quantifier** â€” a way to make formal statements about the *existence* of something satisfying a condition.

<DefinitionBox term="Existential Quantifier (âˆƒ)">

The expression $\exists x \in A.\; P(x)$ reads: "**there exists** an $x$ in $A$ such that $P(x)$ is true."

It asserts that at least one element in $A$ satisfies the predicate $P$.

</DefinitionBox>

We've been doing this informally all along! Every time a math class asked you to "find an $x$" or asked "does such an $x$ exist?", you were being asked to evaluate an existentially quantified statement.

> **ðŸ’¡ Side Note:** Sometimes the domain is omitted when it's clear from context. You might see $\exists x.\; x > 3$ instead of $\exists x \in \mathbb{Z}.\; x > 3$. This is just like in set builder notation where the domain can be implicit. When the domain is missing, assume it's the most natural one for the context.

**Examples:**

| Statement | True/False | Why |
| :--- | :--- | :--- |
| $\exists x \in \mathbb{Z}.\; x > 3$ | True | $x = 4$ works |
| $\exists x \in \mathbb{N}.\; x^2 = 25$ | True | $x = 5$ works |
| $\exists x \in \mathbb{N}.\; x < 0$ | False | No natural is negative |
| $\exists x \in \mathbb{Z}.\; x + 5 = 3$ | True | $x = -2$ works |
| $\exists x.\; x^2 = -1$ | Depends on domain! | True in $\mathbb{C}$, false in $\mathbb{Z}$ |

### Proving Existential Statements

To show an existential statement is **true**, provide a **constructive proof** â€” exhibit a specific witness $x$ that satisfies $P(x)$. This is often the "easiest" direction: just find one example!

To show one is false... we'll need the universal quantifier first. Hold that thought.

### Python Connection

Python's `any()` is the existential quantifier. It takes an iterable of booleans and returns `True` if **at least one** is true:

```python
any(x > 3 for x in range(10))       # True â€” there exists an x > 3
any(x < 0 for x in range(10))       # False â€” no x < 0 in range(10)
any(x**2 == 25 for x in range(10))  # True â€” x = 5 works
```

This is incredibly useful for condensing messy loops. Compare:

```python
# Without any() â€” verbose and nested
found = False
for student in students:
    if student.gpa >= 4.0:
        found = True
        break

# With any() â€” one clean line
found = any(student.gpa >= 4.0 for student in students)
```

It also works on any iterable, including nested structures:

```python
# Does any row in a matrix contain a zero?
matrix = [[1, 2, 3], [4, 0, 6], [7, 8, 9]]
any(0 in row for row in matrix)  # True

# Does any file in the list end with .py?
files = ["main.py", "readme.md", "data.csv"]
any(f.endswith(".py") for f in files)  # True
```

---

## The Universal Quantifier

The second upgrade is the **universal quantifier** â€” a way to make statements about *all* elements satisfying a condition.

<DefinitionBox term="Universal Quantifier (âˆ€)">

The expression $\forall x \in A.\; P(x)$ reads: "**for all** $x$ in $A$, $P(x)$ is true."

It asserts that every element in $A$ satisfies the predicate $P$.

</DefinitionBox>

Just like with the existential quantifier, the domain can be omitted: $\forall x.\; P(x)$ means "for all $x$ (in whatever domain is contextually clear)."

**Examples:**

| Statement | True/False | Why |
| :--- | :--- | :--- |
| $\forall x \in \mathbb{N}.\; x \geq 0$ | True | All naturals are non-negative |
| $\forall x \in \mathbb{Z}.\; x^2 \geq 0$ | True | Squares are always non-negative |
| $\forall x \in \mathbb{N}.\; x > 5$ | False | $x = 0$ is a counterexample |
| $\forall x \in \mathbb{Z}.\; x = 0$ | False | $x = 1$ is a counterexample |
| $\forall x \in \mathbb{N}.\; x + 1 > x$ | True | Adding 1 always increases |

### Proving Universal Statements

To show a universal statement is **true**, you must demonstrate that it's **impossible** for any $x$ not to satisfy the property. This is generally harder than existential â€” you can't just find one example; you need to cover *all* cases.

To show a universal statement is **false**: find just **one counterexample**. That's all it takes â€” a single $x$ where $P(x)$ fails.

### Python Connection

Python's `all()` is the universal quantifier. It takes an iterable of booleans and returns `True` only if **every single one** is true:

```python
all(x >= 0 for x in range(10))      # True â€” all x >= 0
all(x > 5 for x in range(10))       # False â€” x = 0 is a counterexample
all(x + 1 > x for x in range(100))  # True â€” always increases
```

Just like `any()`, this replaces messy loop patterns:

```python
# Without all() â€” verbose with early exit
all_passing = True
for student in students:
    if student.gpa < 2.0:
        all_passing = False
        break

# With all() â€” one clean line
all_passing = all(student.gpa >= 2.0 for student in students)
```

Combining `any()` and `all()` gives you powerful one-liners for complex conditions:

```python
# Are all rows in the matrix non-empty AND does any row contain a zero?
matrix = [[1, 2], [0, 3], [4, 5]]
all(len(row) > 0 for row in matrix)    # True â€” no empty rows
any(0 in row for row in matrix)         # True â€” second row has a zero

# Validate that all emails in a list have an @ symbol
emails = ["alice@lmu.edu", "bob@lmu.edu", "bad-email"]
all("@" in email for email in emails)   # False â€” "bad-email" fails
```

> **ðŸ’¡ Key Insight:** Every time you write a `for` loop that's just checking a condition and setting a boolean flag, ask yourself: "Is this an `any()` or an `all()`?" Recognizing the quantifier pattern makes your code shorter, clearer, and more Pythonic.

---

## Quantifier Duality

Now here's the beautiful symmetry. Compare what it takes to prove each quantifier true or false:

| | To prove **TRUE** | To prove **FALSE** |
| :--- | :--- | :--- |
| $\exists x.\; P(x)$ | Find **ONE** witness | Show **ALL** fail |
| $\forall x.\; P(x)$ | Show **ALL** satisfy | Find **ONE** counterexample |

The difficulty **swaps**! Proving an existential true is easy (find one). Proving it false is hard (show none exist). Proving a universal true is hard (cover all cases). Proving it false is easy (find one counterexample).

This duality has a formal name â€” it's **De Morgan's Laws extended to quantifiers**:

<DisplayMath formula="\lnot(\exists x.\; P(x)) \;\equiv\; \forall x.\; \lnot P(x)" />
<DisplayMath formula="\lnot(\forall x.\; P(x)) \;\equiv\; \exists x.\; \lnot P(x)" />

Negating an existential becomes a universal (and vice versa). "It's not the case that something exists with property P" means "everything fails to have property P." And "it's not the case that everything has property P" means "something exists that fails."

<QuestionBox>

Why does negating a quantifier swap it?

Because saying "nothing exists with property P" requires checking *everything* â€” that's a universal claim. And saying "not everything has property P" only requires finding *one failure* â€” that's an existential claim. Negation swaps the difficulty, which swaps the quantifier.

</QuestionBox>

---

## Relational Properties

Now we have the quantifiers we need. Let's use them to formally define **meta-properties** of relations â€” properties that describe the *nature* of how a relation behaves.

### Reflexivity

<DefinitionBox term="Reflexive">

A relation $R$ on $A$ is **reflexive** if every element is related to itself:

<DisplayMath formula="\forall x \in A.\; R(x, x)" />

</DefinitionBox>

Intuition: the relation lets you compare something to itself, and the answer is always yes.

| Relation | Reflexive? | Why |
| :--- | :--- | :--- |
| $=$ (equality) | Yes | Everything equals itself |
| $\leq$ | Yes | $x \leq x$ for all $x$ |
| $\subseteq$ | Yes | Every set is a subset of itself |
| Logical equivalence ($\equiv$) | Yes | Every statement is equivalent to itself |
| "Has the same birthday as" | Yes | You share your own birthday |
| "Drives the same car as" | Yes | You drive your own car |

### Irreflexivity

<DefinitionBox term="Irreflexive">

A relation $R$ on $A$ is **irreflexive** if no element is related to itself:

<DisplayMath formula="\forall x \in A.\; \lnot R(x, x)" />

</DefinitionBox>

Intuition: the relation *prevents* self-comparison.

| Relation | Irreflexive? | Why |
| :--- | :--- | :--- |
| $\lt$ (strict less than) | Yes | Nothing is strictly less than itself |
| $\gt$ | Yes | Nothing is strictly greater than itself |
| $\subset$ (proper subset) | Yes | No set is a proper subset of itself |
| "Has strictly more money than" | Yes | You don't have strictly more than yourself |
| "Is taller than" | Yes | You aren't taller than yourself |

> **ðŸ¤” But wait...** Can a relation be *neither* reflexive *nor* irreflexive? Yes! Consider conjunction ($\land$) as a relation on booleans: $T \land T = T$ (reflexive for True), but $F \land F = F$ (irreflexive for False). It's reflexive for some elements and irreflexive for others â€” so it's neither fully reflexive nor fully irreflexive.

### Symmetry

<DefinitionBox term="Symmetric">

A relation $R$ on $A$ is **symmetric** if relating one way implies relating the other way:

<DisplayMath formula="\forall x, y \in A.\; R(x, y) \to R(y, x)" />

</DefinitionBox>

Intuition: the relationship always goes both ways.

| Relation | Symmetric? | Why |
| :--- | :--- | :--- |
| $=$ (equality) | Yes | If $a = b$ then $b = a$ |
| Logical equivalence | Yes | If $A \equiv B$ then $B \equiv A$ |
| Congruence | Yes | If $a \equiv b \pmod{n}$ then $b \equiv a \pmod{n}$ |
| "Has the same birthday as" | Yes | If I share your birthday, you share mine |
| "Is genetically related to" | Yes | Genetic relation is mutual |
| $\lt$ | No | $3 < 5$ but $5 \not< 3$ |
| "Is a parent of" | No | If I'm your parent, you're not mine |

### Asymmetry

<DefinitionBox term="Asymmetric">

A relation $R$ on $A$ is **asymmetric** if relating one way implies the other direction does NOT hold:

<DisplayMath formula="\forall x, y \in A.\; R(x, y) \to \lnot R(y, x)" />

</DefinitionBox>

Intuition: the relationship can only go one way. It's a one-way street.

| Relation | Asymmetric? | Why |
| :--- | :--- | :--- |
| $\lt$ | Yes | If $a < b$ then $b \not< a$ |
| $\gt$ | Yes | If $a > b$ then $b \not> a$ |
| $\subset$ | Yes | If $A \subset B$ then $B \not\subset A$ |
| "Is a parent of" | Yes | One-directional |
| "Is strictly taller than" | Yes | One-directional |

### Antisymmetry

<DefinitionBox term="Antisymmetric">

A relation $R$ on $A$ is **antisymmetric** if both directions holding forces the elements to be identical:

<DisplayMath formula="\forall x, y \in A.\; (R(x, y) \;\land\; R(y, x)) \to x = y" />

</DefinitionBox>

Intuition: two-way relating forces identity. The only way to have both $R(x, y)$ and $R(y, x)$ is if $x$ and $y$ are actually the same thing.

| Relation | Antisymmetric? | Why |
| :--- | :--- | :--- |
| $\leq$ | Yes | If $a \leq b$ and $b \leq a$, then $a = b$ |
| $\subseteq$ | Yes | If $A \subseteq B$ and $B \subseteq A$, then $A = B$ |
| $=$ | Yes | Trivially â€” equality only goes both ways for identical items |
| "Has the same birthday as" | No | Two *different* people can share a birthday |

> **ðŸ’¡ Key Distinction:** Antisymmetric is NOT the opposite of symmetric! A relation can be *both* symmetric and antisymmetric (like $=$). The key difference: symmetric says "both ways is normal," antisymmetric says "both ways forces equality." A relation like "has the same birthday as" is symmetric but NOT antisymmetric (different people can share birthdays).

### Transitivity

<DefinitionBox term="Transitive">

A relation $R$ on $A$ is **transitive** if the relationship chains:

<DisplayMath formula="\forall x, y, z \in A.\; (R(x, y) \;\land\; R(y, z)) \to R(x, z)" />

</DefinitionBox>

Intuition: if $x$ is related to $y$, and $y$ is related to $z$, then $x$ is related to $z$.

| Relation | Transitive? | Why |
| :--- | :--- | :--- |
| $=$ | Yes | If $a = b$ and $b = c$, then $a = c$ |
| $\lt$ | Yes | If $a < b$ and $b < c$, then $a < c$ |
| $\leq$ | Yes | If $a \leq b$ and $b \leq c$, then $a \leq c$ |
| $\subseteq$ | Yes | If $A \subseteq B$ and $B \subseteq C$, then $A \subseteq C$ |
| "Is an ancestor of" | Yes | Your ancestor's ancestor is your ancestor |
| "Is taller than" | Yes | If A is taller than B, and B than C, then A is taller than C |
| $\in$ (membership) | **No** | $1 \in \{1,2\}$ and $\{1,2\} \in \{\{1,2\}, \{3\}\}$ does NOT mean $1 \in \{\{1,2\}, \{3\}\}$ |

### Totality

<DefinitionBox term="Total (Connex)">

A relation $R$ on $A$ is **total** if every pair of elements is comparable:

<DisplayMath formula="\forall x, y \in A.\; R(x, y) \;\lor\; R(y, x)" />

</DefinitionBox>

Intuition: the relation always has an opinion. There are no "incomparable" pairs â€” for any two elements, at least one direction holds.

| Relation | Total? | Why |
| :--- | :--- | :--- |
| $\leq$ on numbers | Yes | Any two numbers can be compared |
| $\geq$ on numbers | Yes | Any two numbers can be compared |
| $\subseteq$ on sets | **No** | $\{1,2\}$ and $\{2,3\}$ â€” neither is a subset of the other! |
| "Is an ancestor of" | **No** | Two strangers may have no ancestor relationship |

This is the property that separates a **partial** order from a **total** order: a partial order allows incomparable pairs; a total order requires every pair to be comparable.

> **ðŸ’¡ Side Note:** Totality implies reflexivity (just set $x = y$ in the formula). So a total relation is automatically reflexive.

---

## Why Do We Care?

Pause and reflect. These meta-properties tell us the **nature** of a relation â€” its "feel" or "truth."

Remember from LN6: associativity + commutativity together define what it means to be "addition-like." The operation isn't about numbers â€” it's about those properties! The same insight applies here: **combinations of relational properties define fundamental mathematical concepts**.

Let's see the two most important combinations.

---

## Equivalence Relations

<DefinitionBox term="Equivalence Relation">

A relation $R$ is an **equivalence relation** if it is:

1. **Reflexive**: $\forall x.\; R(x, x)$
2. **Symmetric**: $R(x, y) \to R(y, x)$
3. **Transitive**: $(R(x, y) \land R(y, z)) \to R(x, z)$

</DefinitionBox>

Being "equal" was never about what you were in particular â€” only that when you compare yourself to another, the comparison is reflexive, symmetric, and transitive!

**Examples:**

| Relation | Reflexive | Symmetric | Transitive | Equivalence? |
| :--- | :---: | :---: | :---: | :---: |
| $=$ (equality) | âœ“ | âœ“ | âœ“ | **Yes** |
| Logical equivalence ($\equiv$) | âœ“ | âœ“ | âœ“ | **Yes** |
| Congruence mod $n$ | âœ“ | âœ“ | âœ“ | **Yes** |
| "Has the same birthday as" | âœ“ | âœ“ | âœ“ | **Yes** |
| "Is the same color as" | âœ“ | âœ“ | âœ“ | **Yes** |
| $\leq$ | âœ“ | âœ— | âœ“ | No (not symmetric) |
| $\lt$ | âœ— | âœ— | âœ“ | No (not reflexive) |

### How Each Property Contributes

- **Reflexivity**: you are equivalent to yourself. Without this, some items would have no equivalence class.
- **Symmetry**: if A is equivalent to B, then B is equivalent to A. Equivalence is mutual â€” it doesn't privilege one direction.
- **Transitivity**: equivalence chains. If A is equivalent to B, and B is equivalent to C, then A is equivalent to C.

All three together: an equivalence relation **partitions** a set into groups of "equivalent" items. Every element belongs to exactly one group. These groups are called **equivalence classes** â€” a concept we'll explore in future lectures.

---

## Partial Orders

<DefinitionBox term="Partial Order">

A relation $R$ is a **partial order** if it is:

1. **Reflexive**: $\forall x.\; R(x, x)$
2. **Antisymmetric**: $(R(x, y) \land R(y, x)) \to x = y$
3. **Transitive**: $(R(x, y) \land R(y, z)) \to R(x, z)$

</DefinitionBox>

**Examples:** $\leq$, $\geq$, $\subseteq$, $\supseteq$, "has at most as much knowledge as"

### How Each Property Contributes

- **Reflexivity**: everything is at least as big/small as itself. This anchors the ordering.
- **Antisymmetry**: if $a \leq b$ and $b \leq a$, they must be equal. No distinct ties â€” two-way ordering forces identity.
- **Transitivity**: ordering chains. If $a \leq b$ and $b \leq c$, then $a \leq c$.

The word "partial" means: some pairs might be **incomparable**. With $\subseteq$ on sets, the sets $\{1,2\}$ and $\{2,3\}$ can't be compared â€” neither is a subset of the other. There's no "gap" to fill; they simply exist side by side without an ordering relationship.

---

## Total Orders

<DefinitionBox term="Total Order">

A relation $R$ is a **total order** if it is a partial order that is also **total**:

1. **Reflexive**
2. **Antisymmetric**
3. **Transitive**
4. **Total**: $\forall x, y.\; R(x, y) \lor R(y, x)$

</DefinitionBox>

**Examples:** $\leq$ on numbers, $\geq$ on numbers, alphabetical ordering on strings

**Not a total order:** $\subseteq$ on sets â€” it's a partial order but not total (some sets are incomparable).

This is why it's called "partial" â€” a partial order allows gaps where pairs can't be compared. A total order fills in all the gaps: every pair must be comparable.

### The Big Comparison

| Property | Equivalence | Partial Order | Total Order |
| :--- | :---: | :---: | :---: |
| Reflexive | âœ“ | âœ“ | âœ“ |
| Symmetric | âœ“ | â€” | â€” |
| Antisymmetric | â€” | âœ“ | âœ“ |
| Transitive | âœ“ | âœ“ | âœ“ |
| Total | â€” | â€” | âœ“ |

The difference between equivalence and orders is **symmetry vs antisymmetry**. Equivalence says "relating both ways is normal." Orders say "relating both ways forces equality."

The difference between partial and total orders is **totality** â€” whether every pair must be comparable.

> **ðŸŒŸ Big Picture:** Just like associativity + commutativity make "addition," reflexivity + symmetry + transitivity make "equivalence," and reflexivity + antisymmetry + transitivity make "partial ordering." These aren't definitions we invented arbitrarily â€” they capture the essential *feel* of what it means for things to be equal or orderable.

---

## Relations in Python

Let's bring this back to code. Understanding relational properties makes you a better Python programmer â€” because Python's built-in functions **require** these properties as contracts.

### Dunder Methods Are Relations

Python's comparison dunder methods are literally relations:

| Dunder Method | Relation | Math | Properties |
| :--- | :--- | :--- | :--- |
| `__eq__` | Equality | $=$ | Equivalence relation |
| `__lt__` | Less than | $\lt$ | Strict partial order |
| `__le__` | Less or equal | $\leq$ | Partial order |
| `__gt__` | Greater than | $\gt$ | Strict partial order |
| `__ge__` | Greater or equal | $\geq$ | Partial order |

When you implement `__eq__`, you're defining an equivalence relation. When you implement `__lt__`, you're defining an ordering relation.

```python
class Student:
    def __init__(self, name, gpa):
        self.name = name
        self.gpa = gpa

    def __eq__(self, other):
        return self.gpa == other.gpa

    def __lt__(self, other):
        return self.gpa < other.gpa

    def __le__(self, other):
        return self == other or self < other

    def __repr__(self):
        return f"Student({self.name}, {self.gpa})"
```

Our `__eq__` is reflexive (same GPA = same GPA), symmetric (if A's GPA equals B's, then B's equals A's), and transitive â€” it's a valid equivalence relation!

And `__le__` based on GPA is reflexive, antisymmetric, and transitive â€” a valid partial order. Since every two GPAs (as numbers) are comparable, it's actually a total order.

### Sorting Requires a Total Order

Python's `sorted()` **requires** a total order: reflexive, antisymmetric, transitive, and every pair comparable. If your comparison violates these properties, sorting breaks!

```python
students = [Student("Alice", 3.8), Student("Bob", 3.5), Student("Carol", 3.9)]
sorted(students)  # Works! [Student(Bob, 3.5), Student(Alice, 3.8), Student(Carol, 3.9)]
```

This works because `__lt__` on GPA defines a valid total order. But what if your comparison were non-transitive? If A beats B, and B beats C, but C beats A (like rock-paper-scissors), then `sorted()` would produce **inconsistent, unpredictable results**. The meta-properties aren't abstract theory â€” they're the **contract** your code must satisfy.

Python even provides a shortcut: `@functools.total_ordering` auto-generates `__le__`, `__gt__`, and `__ge__` from just `__eq__` + `__lt__`:

```python
from functools import total_ordering

@total_ordering
class Student:
    def __init__(self, name, gpa):
        self.name = name
        self.gpa = gpa

    def __eq__(self, other):
        return self.gpa == other.gpa

    def __lt__(self, other):
        return self.gpa < other.gpa
```

Python trusts that if you give it `__eq__` and `__lt__`, the rest of the ordering follows from the relational properties. That's trust built on the formal foundations we just learned!

### Hashability: A Programming Property

In LN9, we saw that Python sets require **hashable** elements. Now we can explain *why* from a relational perspective.

Being hashable means satisfying a formal contract:

1. `__eq__` must define an **equivalence relation** (reflexive, symmetric, transitive)
2. `__hash__` must be **consistent with equality**: if `a == b`, then `hash(a) == hash(b)`
3. The hash must not change over the object's lifetime (**immutability**)

If you override `__eq__` without defining `__hash__`, Python automatically makes your class **unhashable** â€” it's protecting the equivalence relation contract! Python knows that a broken equality-hash relationship would corrupt sets and dictionaries.

Here's what happens when you violate the contract:

```python
class BadPoint:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x

    def __hash__(self):
        return hash((self.x, self.y))

p1 = BadPoint(1, 2)
p2 = BadPoint(1, 3)
p1 == p2              # True (same x)
hash(p1) == hash(p2)  # False! (different y)
# Sets may now contain "duplicate" equal items â€” undefined behavior!
```

The `__eq__` says p1 and p2 are equivalent, but `__hash__` disagrees. This violates the contract, and sets can now contain what should be "the same" item multiple times â€” breaking the fundamental guarantee that sets have no duplicates.

> **ðŸ“Œ Key Insight:** Python's `sorted()` requires a total order. Python's `set` and `dict` require a valid equivalence relation (via `__eq__`) consistent with hashing. These aren't arbitrary API requirements â€” they're formal relational properties baked into the language. Understanding the math makes the Python contracts obvious.

---

<LectureNotes>

**Key Definitions:**

- **Relation** â€” An operation $R : (A, A) \to$ Bool that tests a relationship
- **Existential Quantifier** ($\exists$) â€” $\exists x \in A.\; P(x)$: "there exists an $x$ such that..."
- **Universal Quantifier** ($\forall$) â€” $\forall x \in A.\; P(x)$: "for all $x$..."
- **Reflexive** â€” $\forall x.\; R(x, x)$
- **Irreflexive** â€” $\forall x.\; \lnot R(x, x)$
- **Symmetric** â€” $R(x, y) \to R(y, x)$
- **Asymmetric** â€” $R(x, y) \to \lnot R(y, x)$
- **Antisymmetric** â€” $(R(x, y) \land R(y, x)) \to x = y$
- **Transitive** â€” $(R(x, y) \land R(y, z)) \to R(x, z)$
- **Total** â€” $\forall x, y.\; R(x, y) \lor R(y, x)$
- **Equivalence Relation** â€” Reflexive + Symmetric + Transitive
- **Partial Order** â€” Reflexive + Antisymmetric + Transitive
- **Total Order** â€” Partial Order + Total

**Quantifier Duality (De Morgan's for Quantifiers):**

| | Prove TRUE | Prove FALSE |
| :--- | :--- | :--- |
| $\exists x.\; P(x)$ | Find one witness | Show all fail |
| $\forall x.\; P(x)$ | Show all satisfy | Find one counterexample |

**Composed Relations:**

| Property | Equivalence | Partial Order | Total Order |
| :--- | :---: | :---: | :---: |
| Reflexive | âœ“ | âœ“ | âœ“ |
| Symmetric | âœ“ | â€” | â€” |
| Antisymmetric | â€” | âœ“ | âœ“ |
| Transitive | âœ“ | âœ“ | âœ“ |
| Total | â€” | â€” | âœ“ |

**Python Contracts:**

| Python Feature | Required Property |
| :--- | :--- |
| `sorted()` | Total order via `__lt__` |
| `set` / `dict` membership | Equivalence relation via `__eq__` + consistent `__hash__` |
| `@functools.total_ordering` | Generates full ordering from `__eq__` + `__lt__` |

</LectureNotes>

<LectureResources>

### Recommended Viewing

- [Trefor Bazett: "Relations and Their Properties"](https://www.youtube.com/watch?v=GQSH2aN6JfA) â€” Clear walkthrough of reflexivity, symmetry, transitivity
- [Computerphile: "Equivalence Relations"](https://www.youtube.com/watch?v=2S4nn7S8Hk4) â€” Accessible introduction with examples

### Further Reading

- [Wikipedia: Binary Relation](https://en.wikipedia.org/wiki/Binary_relation) â€” Comprehensive treatment of relation properties
- [Wikipedia: Equivalence Relation](https://en.wikipedia.org/wiki/Equivalence_relation) â€” Reflexive + symmetric + transitive
- [Wikipedia: Partial Order](https://en.wikipedia.org/wiki/Partially_ordered_set) â€” Reflexive + antisymmetric + transitive
- [Wikipedia: Total Order](https://en.wikipedia.org/wiki/Total_order) â€” When every pair is comparable

### Historical Context

- **Augustus De Morgan** (1806-1871) â€” Quantifier duality extends his famous laws to quantifiers
- **Ernst SchrÃ¶der** (1841-1902) â€” Pioneered the algebra of relations
- **Gottlob Frege** (1848-1925) â€” Formalized quantifiers in modern predicate logic

### Connection to Programming

- Python's `any()` and `all()` are the existential and universal quantifiers
- Dunder methods (`__eq__`, `__lt__`, etc.) define relations on objects
- `sorted()` requires a total order â€” violating transitivity causes undefined sorting behavior
- `__eq__` + `__hash__` consistency is a formal equivalence-relation contract required for sets and dicts
- `@functools.total_ordering` auto-generates ordering methods from the minimal `__eq__` + `__lt__`

</LectureResources>
