import { DisplayMath } from "@/components/math"
import {
  LectureNotes,
  LectureResources,
} from "@/components/lecture-sections"
import { QuestionBox } from "@/components/question-box"

## Recap

Last time we explored the **Boolean Type** through George Boole's historical discovery. We expanded on **reducibility** â€” how different systems can solve the same problem â€” and used that insight to visualize logical operations with **Venn Diagrams**.

---

## Today's Agenda

- **Operator Syntax** â€” Types tell us what operators mean
- **Operator Notation** â€” Many ways to write the same operation  
- **The Big Reveal** â€” Addition isn't about numbers!

---

## Operator Syntax and Types

So far, our type judgments look like this:

<DisplayMath formula="a : A" />

But operators are **functions**, not just values. Addition takes two inputs and produces an output:

<DisplayMath formula="+ : (\mathbb{N}, \mathbb{N}) \to \mathbb{N}" />

This reads: "the `+` operator takes two natural numbers and returns a natural number."

### Type Signatures for Operators

We can capture the behavior of all our operators this way:

| Operator | Type Signature |
| :--- | :--- |
| Conjunction | $\land : (\text{Bool}, \text{Bool}) \to \text{Bool}$ |
| Disjunction | $\lor : (\text{Bool}, \text{Bool}) \to \text{Bool}$ |
| Negation | $\lnot : \text{Bool} \to \text{Bool}$ |
| Implication | $\to : (\text{Bool}, \text{Bool}) \to \text{Bool}$ |

Remember: Boole discovered that arithmetic on 0 and 1 represents logic! So arithmetic operators can work on Booleans too:

<DisplayMath formula="\times : (\text{Bool}, \text{Bool}) \to \text{Bool}" />
<DisplayMath formula="+ : (\text{Bool}, \text{Bool}) \to \text{Bool}" />

### Operator Overloading

The **type** disambiguates meaning. The same symbol can mean different things:

| Type Signature | Meaning |
| :--- | :--- |
| $+ : (\mathbb{N}, \mathbb{N}) \to \mathbb{N}$ | Add naturals |
| $+ : (\mathbb{Z}, \mathbb{Z}) \to \mathbb{Z}$ | Add integers |
| $+ : (\mathbb{R}, \mathbb{R}) \to \mathbb{R}$ | Add reals |
| $+ : (\text{String}, \text{String}) \to \text{String}$ | Concatenate strings |
| $+ : (\text{Bool}, \text{Bool}) \to \text{Bool}$ | Boolean OR |

This is called **overloading** â€” the `+` symbol means different things based on context!

---

## Operator Notation

Beyond meaning, we also vary how operators **look**. The same operation can be written multiple ways:

| Notation | Addition | Division | Exponentiation |
| :--- | :--- | :--- | :--- |
| **Infix** | $a + b$ | $a \div b$ | $a \wedge b$ |
| **Prefix** | $+\ a\ b$ | $\div\ a\ b$ | $\wedge\ a\ b$ |
| **Postfix** | $a\ b\ +$ | $a\ b\ \div$ | $a\ b\ \wedge$ |

**Why different notations?** Each has advantages:

- **Infix** ($a + b$) â€” Familiar, reads naturally
- **Prefix** ($+\ a\ b$) â€” Chains easily: $+\ a\ b\ c\ d$ means $a + b + c + d$
- **Postfix** ($a\ b\ +$) â€” No parentheses needed, used in calculators

Clojure uses prefix notation:

```clojure
(+ 1 2 3 4)  ; => 10 (adds all arguments)
```

### Familiar "Weird" Notations

You already use unconventional notations without thinking:

<DisplayMath formula="\log_b(a) \quad \sqrt{a} \quad \frac{a}{b} \quad \int a \, dx \quad a^b" />

Fractions use **vertical** layout. Exponents use **superscript**. Integrals wrap around their argument. These aren't infix, prefix, or postfix â€” they're custom notations designed for clarity.

### Juxtaposition

Sometimes operators are so common we omit the symbol entirely:

| Written | Meaning |
| :--- | :--- |
| $ab$ | $a \times b$ (multiplication) |
| $AB$ | $A \land B$ (conjunction) |
| $fa$ | $f(a)$ (function application) |

### Unary Operators

Operators with one argument also have multiple notations. Negation alone has six common forms:

<DisplayMath formula="\lnot A \quad \sim A \quad !A \quad \bar{A} \quad A' \quad A^c" />

Type signature: $\lnot : \text{Bool} \to \text{Bool}$

### Ternary Operators

What about three arguments? The **conditional operator** is a classic example:

<DisplayMath formula="\text{condition} \; ? \; \text{consequence} : \text{alternative}" />

Type: $? : (\text{Bool}, \text{Any}, \text{Any}) \to \text{Any}$

If the condition is true, return the consequence; otherwise, return the alternative.

```python
# Python's version reads like English:
x = 1 if condition else 2
```

---

> **ðŸ’¡ Key Insight:** Syntax is flexible! The **type** tells us what an operator does. The **notation** is just how we choose to write it. Different fields use different notations because they clarify different things.

---

## Addition isn't about numbers...

The previous lecture was to expand your understanding of mathematics to include the idea that completely separate systems of reasoning can be used to solve the same problem.
The previous part of this lecture was to show you it's very common to make new and useful ways to visualize different things.

So now we embark on the journey of showing you that this leads to an amazing conclusion!

It turns out that addition isn't about numbers at all! Let's find out why!

---

### The Number Line: Your First Addition System

Remember the number line from grade school? Before you ever learned algebra, you learned to add by **moving along a line**.

Let's revisit that, but this time we'll hide the numbers to reveal what's really happening:

import { NumberLine } from "@/components/number-line"

<NumberLine
  start={0}
  hops={[1, 4]}
  showNumbers={true}
  hopLabels={["+1", "+4"]}
  caption="1 + 4 = 5 on a number line"
/>

Now let's see the same operation **without any numbers visible**:

<NumberLine
  start={0}
  hops={[1, 4]}
  showNumbers={false}
  hopLabels={["hop", "hop hop hop hop"]}
  caption="Addition without numbers â€” just movement!"
/>

Let's try another example: **2 + 3 = 5**

<NumberLine
  start={0}
  hops={[2, 3]}
  showNumbers={true}
  hopLabels={["+2", "+3"]}
  caption="2 + 3 = 5 on a number line"
/>

And again without numbers:

<NumberLine
  start={0}
  hops={[2, 3]}
  showNumbers={false}
  hopLabels={["hop hop", "hop hop hop"]}
  caption="Same operation, no numbers â€” still works!"
/>

What do you notice? Addition on the number line is really about **movement** and **direction**:
- Start somewhere
- Move in a direction
- Your destination is the "sum"

The numbers are just labels for positions â€” the actual operation is **combining movements**.

> **ðŸ’¡ Key Insight:** Addition is about **movement/direction**, not values. The number line taught us this as children, but we forgot it when we learned algebra!

---

### Addition as Chain Building

Here's another way to visualize addition that has nothing to do with arithmetic.

import { GraphVisualization } from "@/components/graph-visualization"

**What is "1"?** A single node:

<GraphVisualization
  nodes={[
    { id: "a", label: "â—" },
  ]}
  edges={[]}
  height="200px"
/>

**What is "4"?** Four separate nodes:

<GraphVisualization
  nodes={[
    { id: "b", label: "â—" },
    { id: "c", label: "â—" },
    { id: "d", label: "â—" },
    { id: "e", label: "â—" },
  ]}
  edges={[]}
  height="220px"
/>

**What is "1 + 4"?** Connect them into a chain!

<GraphVisualization
  nodes={[
    { id: "a", label: "â—" },
    { id: "b", label: "â—" },
    { id: "c", label: "â—" },
    { id: "d", label: "â—" },
    { id: "e", label: "â—" },
  ]}
  edges={[
    { from: "a", to: "b" },
    { from: "b", to: "c" },
    { from: "c", to: "d" },
    { from: "d", to: "e" },
  ]}
  height="220px"
/>

The result "5" is just the length of the combined chain!

Let's try another example: **2 + 3 = 5**

**What is "2"?** Two nodes:

<GraphVisualization
  nodes={[
    { id: "p", label: "â—" },
    { id: "q", label: "â—" },
  ]}
  edges={[]}
  height="100px"
/>

**What is "3"?** Three nodes:

<GraphVisualization
  nodes={[
    { id: "r", label: "â—" },
    { id: "s", label: "â—" },
    { id: "t", label: "â—" },
  ]}
  edges={[]}
  height="220px"
/>

**What is "2 + 3"?** Connect them into a chain!

<GraphVisualization
  nodes={[
    { id: "p", label: "â—" },
    { id: "q", label: "â—" },
    { id: "r", label: "â—" },
    { id: "s", label: "â—" },
    { id: "t", label: "â—" },
  ]}
  edges={[
    { from: "p", to: "q" },
    { from: "q", to: "r" },
    { from: "r", to: "s" },
    { from: "s", to: "t" },
  ]}
  height="120px"
/>

Again, the result "5" is the length of the combined chain â€” no numbers needed!

> **ðŸ’¡ Key Insight:** Addition is about **combining/concatenating** â€” linking things together. No arithmetic required!

---

### String Concatenation: Addition Without Numbers

You've been doing "addition" with strings this whole time:

```python
"Hello" + " " + "World"
# => "Hello World"
```

There are no numbers here, yet the `+` operator feels natural. Why?

Because string concatenation **combines** things, just like:
- Number line hops combine movements
- Graph chains combine nodes
- Numbers combine quantities

Remember our type signature from earlier?

```
+ : (String, String) -> String
```

The `+` operator is overloaded to work on strings because concatenation shares something fundamental with addition...

But what exactly do they share? Let's find out!

---

## What Makes Addition... Addition?

We've seen addition in three different systems:
1. **Number line** â€” combining movements
2. **Graphs** â€” combining chains
3. **Strings** â€” combining text

They all *feel* like addition, but they look completely different. What do they have in common?

The answer comes from **Abstract Algebra**, and it will change how you think about mathematics forever.

import { DefinitionBox } from "@/components/interactive-example"

---

### The Commutative Property

<DefinitionBox term="Commutative Property">

An operation `âŠ•` is **commutative** if the order of operands doesn't matter:

`a âŠ• b = b âŠ• a`

</DefinitionBox>

Let's test our systems:

**Numbers:** `1 + 4 = 4 + 1 = 5` âœ“

**Number Line:** Does it matter if we hop +1 then +4, or hop +4 then +1?

<NumberLine
  start={0}
  hops={[1, 4]}
  showNumbers={true}
  hopLabels={["+1", "+4"]}
  caption="1 + 4: hop 1, then hop 4"
/>

<NumberLine
  start={0}
  hops={[4, 1]}
  showNumbers={true}
  hopLabels={["+4", "+1"]}
  caption="4 + 1: hop 4, then hop 1 â€” same destination!"
/>

Both paths land at position 5! The number line is **commutative**. âœ“

**Graph Chains:** Does it matter which chain we connect first?

<GraphVisualization
  nodes={[
    { id: "a", label: "A" },
    { id: "b", label: "B" },
    { id: "c", label: "C" },
    { id: "d", label: "D" },
    { id: "e", label: "E" },
  ]}
  edges={[
    { from: "a", to: "b" },
    { from: "b", to: "c" },
    { from: "c", to: "d" },
    { from: "d", to: "e" },
  ]}
  height="220px"
/>

Whether we connect "1 node to 4 nodes" or "4 nodes to 1 node", we get the same 5-node chain. âœ“

**Strings:** `"Hello" + "World"` vs `"World" + "Hello"`...

```python
"Hello" + "World"  # => "HelloWorld"
"World" + "Hello"  # => "WorldHello"
```

**Wait!** These are NOT the same! String concatenation is **NOT commutative**! âœ—

> ðŸš¨ **Important:** We found our first difference! Keep this in mind...

---

### The Associative Property

<DefinitionBox term="Associative Property">

An operation `âŠ•` is **associative** if grouping doesn't matter:

`(a âŠ• b) âŠ• c = a âŠ• (b âŠ• c)`

</DefinitionBox>

Let's test again:

**Numbers:** `(1 + 2) + 3 = 3 + 3 = 6` and `1 + (2 + 3) = 1 + 5 = 6` âœ“

**Number Line:** Let's compare `(1 + 4) + 2` vs `1 + (4 + 2)`:

<NumberLine
  start={0}
  hops={[1, 4, 2]}
  showNumbers={true}
  hopLabels={["(+1", "+4)", "+2"]}
  max={8}
  caption="(1 + 4) + 2: Compute 1+4 first (=5), then add 2"
/>

<NumberLine
  start={0}
  hops={[1, 6]}
  showNumbers={true}
  hopLabels={["+1", "(+4+2)"]}
  max={8}
  caption="1 + (4 + 2): Compute 4+2 first (=6), then add to 1"
/>

Both arrive at 7! Whether we compute `(1+4)+2 = 5+2 = 7` or `1+(4+2) = 1+6 = 7`, the destination is the same. Grouping doesn't matter. âœ“

**Graph Chains:** Whether we connect (A-B) then C, or A then (B-C), we get the same chain. âœ“

**Strings:** `("a" + "b") + "c"` vs `"a" + ("b" + "c")`:

```python
("a" + "b") + "c"  # => "ab" + "c" => "abc"
"a" + ("b" + "c")  # => "a" + "bc" => "abc"
```

Both give `"abc"`! String concatenation IS **associative**. âœ“

---

### The Big Reveal

Here's what Abstract Algebra tells us:

> **An operation that is both commutative AND associative behaves like addition.**

This is the mathematical definition of "addition-like" behavior. The name of the operation doesn't matter. The symbol doesn't matter. Only these **properties** matter!

| System | Commutative? | Associative? | "Addition"? |
| :--- | :--- | :--- | :--- |
| Number addition | âœ“ | âœ“ | **Yes** |
| Number line hops | âœ“ | âœ“ | **Yes** |
| Graph chain building | âœ“ | âœ“ | **Yes** |
| String concatenation | âœ— | âœ“ | **No!** |

String concatenation uses the `+` symbol, but it's **not mathematically addition** because it's not commutative!

---

### The Mind-Bending Examples

If addition is defined by commutativity and associativity, what about other operations?

**Multiplication:**
- Commutative? `a Ã— b = b Ã— a` âœ“
- Associative? `(a Ã— b) Ã— c = a Ã— (b Ã— c)` âœ“

**Wait... is multiplication also "addition"?!**

Yes! Multiplication satisfies both properties â€” it's structurally "additive"!

**Boolean AND (âˆ§):**
- Commutative? `A âˆ§ B = B âˆ§ A` âœ“
- Associative? `(A âˆ§ B) âˆ§ C = A âˆ§ (B âˆ§ C)` âœ“

**Boolean OR (âˆ¨):**
- Commutative? `A âˆ¨ B = B âˆ¨ A` âœ“
- Associative? `(A âˆ¨ B) âˆ¨ C = A âˆ¨ (B âˆ¨ C)` âœ“

AND and OR are both "addition" too!

> **ðŸ¤¯ Mind-Blown Moment:** Multiplication (Ã—) is mathematically "addition" even though it uses a different symbol. String concatenation (+) is NOT mathematically "addition" even though it uses the + symbol!

**The symbol is just syntax. The PROPERTIES define the true nature of an operation.**

This feels wrong because we were taught these are "different" operations. But Abstract Algebra reveals they share the same fundamental structure! We just gave them different names based on what they operate on, not based on their mathematical behavior.

---

### The String Concatenation Trap

Let's really drive this home.

We programmers have been using `+` for strings forever:

```python
greeting = "Hello" + " " + "World"
```

But here's the uncomfortable truth:

| Operation | Symbol | Commutative | Associative | Mathematically "Addition"? |
| :--- | :--- | :--- | :--- | :--- |
| Multiplication | `Ã—` | Yes | Yes | **YES** |
| Boolean AND | `âˆ§` | Yes | Yes | **YES** |
| Boolean OR | `âˆ¨` | Yes | Yes | **YES** |
| String concat | `+` | **No** | Yes | **NO** |

The operation that *looks* most like addition (uses `+`) is the one that *isn't* addition!

This is a perfect example of **syntax misleading us**. Programmers borrowed the `+` notation because concatenation *feels* like adding, but it doesn't satisfy the mathematical requirements.

> **ðŸ“š Formal Term:** String concatenation forms a **monoid** (associative with identity), but not an **abelian group** (which requires commutativity). Addition, multiplication, AND, and OR all form abelian groups over their domains!

---

## More Algebraic Properties

Commutativity and associativity are just the beginning. Let's explore two more fundamental properties that help characterize operations.

---

### The Identity Property

<DefinitionBox term="Identity Property">

An operation `âŠ•` has an **identity element** `e` if combining anything with `e` leaves it unchanged:

`a âŠ• e = a` and `e âŠ• a = a`

</DefinitionBox>

Every "addition-like" operation has an identity â€” something that "does nothing":

| System | Operation | Identity Element | Example |
| :--- | :--- | :--- | :--- |
| Natural numbers | Addition | `0` | `5 + 0 = 5` |
| Natural numbers | Multiplication | `1` | `5 Ã— 1 = 5` |
| Number line | Hops | 0-hop (stay in place) | `position + 0 = position` |
| Graphs | Chain building | Empty chain | `chain âŠ• âˆ… = chain` |
| Strings | Concatenation | `""` (empty string) | `"hello" + "" = "hello"` |
| Booleans | OR (âˆ¨) | `False` | `A âˆ¨ False = A` |
| Booleans | AND (âˆ§) | `True` | `A âˆ§ True = A` |

Notice something interesting:
- Addition's identity is `0`
- Multiplication's identity is `1`
- AND's identity is `True`
- OR's identity is `False`

The identity depends on the operation, not the type!

> **ðŸ’¡ Key Insight:** Even string concatenation has an identity (the empty string). Having an identity doesn't make something "addition" â€” you also need commutativity!

---

### The Closure Property

<DefinitionBox term="Closure Property">

An operation is **closed** if its output type matches its input types. In our type theory notation:

$\oplus : (A, A) \to A$

The inputs are type `A`, and the output is also type `A`. The operation "stays within" the type.

</DefinitionBox>

You've already seen this pattern! Look at our type signatures:

```
+ : (Natural, Natural) -> Natural   âœ“ Closed!
âˆ§ : (Boolean, Boolean) -> Boolean   âœ“ Closed!
+ : (String, String) -> String      âœ“ Closed!
```

The input types match the output type â€” the operation never "escapes" to a different type.

**But what about subtraction on naturals?**

```
- : (Natural, Natural) -> ???
```

What's `3 - 5`? It's `-2`, which is NOT a natural number! Subtraction on naturals is **NOT closed** â€” the output type doesn't match the input type. We'd have to write:

```
- : (Natural, Natural) -> Integer   âœ— Not closed!
```

| Type | Operation | Type Signature | Closed? |
| :--- | :--- | :--- | :--- |
| Natural | Addition | `(Natural, Natural) -> Natural` | âœ“ |
| Natural | Subtraction | `(Natural, Natural) -> Integer` | **âœ—** |
| Integer | Subtraction | `(Integer, Integer) -> Integer` | âœ“ |
| String | Concatenation | `(String, String) -> String` | âœ“ |
| Boolean | AND | `(Boolean, Boolean) -> Boolean` | âœ“ |
| Boolean | OR | `(Boolean, Boolean) -> Boolean` | âœ“ |

**Why does closure matter?**

If an operation isn't closed, you can "escape" the type! Subtraction on naturals can produce integers, which aren't naturals. This is why mathematicians invented integers â€” to make subtraction closed!

> **ðŸ“š Set Theory Note:** In set theory, this is called being "closed over a set" â€” same idea, different vocabulary. When you take a course on set theory, you'll see closure defined in terms of sets rather than types, but the concept is identical.

---

## The Complete Picture

Let's put it all together with our comprehensive summary:

| System | Operation | Symbol | Commutative | Associative | Identity | Closed | "Addition"? |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| Natural Numbers | Addition | `+` | Yes | Yes | 0 | Yes | **Yes** |
| Natural Numbers | Multiplication | `Ã—` | Yes | Yes | 1 | Yes | **Yes!** |
| Number Line | Hops | â†’ | Yes | Yes | 0-hop | Yes | **Yes** |
| Graphs | Chain Building | âŠ• | Yes | Yes | Empty | Yes | **Yes** |
| Strings | Concatenation | `+` | **No** | Yes | "" | Yes | **No!** |
| Booleans | Disjunction (OR) | `âˆ¨` | Yes | Yes | False | Yes | **Yes!** |
| Booleans | Conjunction (AND) | `âˆ§` | Yes | Yes | True | Yes | **Yes!** |

**The Surprising Truth:**
- Multiplication (Ã—) IS mathematically "addition" â€” despite its different name and symbol
- String concatenation (+) is NOT mathematically "addition" â€” despite using the + symbol
- AND and OR are both mathematically "addition" â€” they're just addition over different domains!

---

## The Bigger Picture: Group Theory

What we've been exploring is the foundation of **Group Theory**, a branch of Abstract Algebra that studies these structural properties.

<DefinitionBox term="Algebraic Structures">

Different combinations of properties define different algebraic structures:

- **Magma**: Just closure (any binary operation)
- **Semigroup**: Closure + Associativity
- **Monoid**: Closure + Associativity + Identity (this is string concatenation!)
- **Group**: Closure + Associativity + Identity + Inverses
- **Abelian Group**: All of the above + Commutativity (this is "addition"!)

</DefinitionBox>

You don't need to memorize these, but notice:
- **String concatenation** is a monoid (no commutativity)
- **Addition, multiplication, AND, OR** are all abelian groups (fully "additive")

> **ðŸ”® Looking Ahead:** These properties will return when you study:
> - **Linear Algebra** â€” Vector addition forms an abelian group
> - **Cryptography** â€” Security relies on group theory
> - **Programming Language Theory** â€” Type systems use algebraic structures
> - **Category Theory** â€” The "algebra of composition"

The seemingly simple question "what is addition?" leads to some of the deepest mathematics in existence!

---

## Applying This in Code

As programmers, we create custom operations all the time. When we overload operators like `+`, we're actually defining new algebraic structures â€” whether we realize it or not. Understanding the meta-properties we've been discussing helps us write better, more predictable code.

### Python's Operator Overloading

In Python, you can define what `+` means for your custom classes using the `__add__` method:

```python
def __add__(self, other) -> Self:
    # Define what a + b means
    return ...
```

Notice anything familiar? The type signature `__add__(self, other) -> Self` is exactly our closure pattern from earlier:

$$
\oplus : (A, A) \rightarrow A
$$

When you write `__add__`, you're defining an algebraic operation!

### The Dot and Group Classes (Addition Without Numbers!)

Let's push our lecture's central point to its logical extreme: **we'll create addition without any numbers at all**.

First, a completely empty `Dot` class â€” just a marker with no numeric properties whatsoever:

```python
class Dot:
    """A simple marker with no numeric properties."""
    pass
```

Now, a `Group` class that holds a collection of Dots and implements `+`:

```python
class Group:
    def __init__(self, dots=None):
        self.dots = dots if dots else []
    
    def __add__(self, other):
        # Create NEW dots for the combined group
        new_dots = []
        for _ in self.dots:
            new_dots.append(Dot())
        for _ in other.dots:
            new_dots.append(Dot())
        return Group(new_dots)
    
    def __eq__(self, other):
        # Groups are equal if they have the same NUMBER of dots
        return len(self.dots) == len(other.dots)
    
    def __len__(self):
        return len(self.dots)
    
    def __repr__(self):
        return f"Group({len(self.dots)} dots)"
```

> **ðŸ’¡ Key Insight:** There are no numbers in our `Dot` class. The `Group` class doesn't store any numeric data â€” it just holds a collection of abstract markers. Yet we can still define addition!

### Testing the Algebraic Properties

Now comes the satisfying part. We can write tests that look exactly like our mathematical definitions:

```python
# Create some groups
a = Group([Dot(), Dot()])           # 2 dots
b = Group([Dot(), Dot(), Dot()])    # 3 dots
c = Group([Dot()])                  # 1 dot
empty = Group([])                   # 0 dots (identity candidate)

# Test closure: Group + Group = Group
result = a + b
assert isinstance(result, Group)  # âœ“ Still a Group!

# Test commutativity: a + b = b + a
assert a + b == b + a  # âœ“ Order doesn't matter!

# Test associativity: (a + b) + c = a + (b + c)
assert (a + b) + c == a + (b + c)  # âœ“ Grouping doesn't matter!

# Test identity: a + empty = a
assert a + empty == a  # âœ“ Empty group is the identity!

print("All algebraic properties verified! âœ“")
```

These tests mirror the exact formulas we saw earlier:
- **Commutativity**: $a \oplus b = b \oplus a$
- **Associativity**: $(a \oplus b) \oplus c = a \oplus (b \oplus c)$
- **Identity**: $a \oplus e = a$

### Why This Matters

Understanding your operation's algebraic properties has real practical benefits:

| Property | Programming Benefit |
| :--- | :--- |
| **Associativity** | Enables parallel processing â€” you can compute `(a + b) + c` and `a + (b + c)` on different cores and get the same result (great for map-reduce!) |
| **Commutativity** | Allows compilers to reorder operations for optimization |
| **Identity** | Gives you a natural "default" or "zero" value for your type |
| **Closure** | Guarantees you can chain operations without type errors |

> **ðŸ”® Real-World Example:** Libraries like NumPy, Pandas, and even database query builders rely on these properties for optimization. When the library knows your operation is associative, it can parallelize it!

### The Type Theory Connection

Let's circle back to the lecture's theme. When you define `__add__`:

```python
def __add__(self, other: "Group") -> "Group":
    ...
```

You're stating the type signature: `+ : (Group, Group) â†’ Group`

This **is** closure! Your type annotation captures the algebraic property. And by ensuring your implementation satisfies commutativity and associativity, you've created something that is mathematically **addition** â€” even though there are no numbers anywhere in sight.

<QuestionBox>

Did we just prove addition isn't about numbers by writing Python code?

Yes! Our `Group + Group` operation satisfies all the same properties as `5 + 3`. The fact that there are no numbers in our implementation proves that addition is defined by its **properties**, not by the objects it operates on.

</QuestionBox>

---



<LectureNotes>

**Key Definitions:**

- **Commutative Property** â€” Order doesn't matter: `a âŠ• b = b âŠ• a`
- **Associative Property** â€” Grouping doesn't matter: `(a âŠ• b) âŠ• c = a âŠ• (b âŠ• c)`
- **Identity Element** â€” An element `e` that leaves others unchanged: `a âŠ• e = a`
- **Closure** â€” Output type matches input types: `âŠ• : (A, A) â†’ A`

**The "Addition" Test:**

An operation is mathematically "addition" if it satisfies:
1. Commutativity âœ“
2. Associativity âœ“

| Operation | Symbol | Commutative | Associative | "Addition"? |
| :--- | :--- | :--- | :--- | :--- |
| Number addition | `+` | âœ“ | âœ“ | Yes |
| Multiplication | `Ã—` | âœ“ | âœ“ | Yes |
| Boolean AND | `âˆ§` | âœ“ | âœ“ | Yes |
| Boolean OR | `âˆ¨` | âœ“ | âœ“ | Yes |
| String concat | `+` | âœ— | âœ“ | **No** |

**The Key Insight:**

The symbol doesn't define the operation â€” the **properties** do:
- Multiplication uses `Ã—` but IS mathematically "addition"
- String concatenation uses `+` but is NOT mathematically "addition"

**Algebraic Structures (for reference):**

- **Monoid** = Associative + Identity (e.g., string concatenation)
- **Abelian Group** = Associative + Commutative + Identity + Inverses (e.g., addition)

</LectureNotes>

<LectureResources>

### Recommended Viewing

- [3Blue1Brown: "Group Theory, Pair of Pants" (2023)](https://www.youtube.com/watch?v=X63MWZIN3gM) â€” Visual introduction to algebraic structures
- [Numberphile: "Abstract Algebra" (2019)](https://www.youtube.com/watch?v=IP7nW_hKB7I) â€” Accessible introduction to the field

### Further Reading

- [Wikipedia: Commutative Property](https://en.wikipedia.org/wiki/Commutative_property) â€” Overview with examples
- [Wikipedia: Associative Property](https://en.wikipedia.org/wiki/Associative_property) â€” Overview with examples
- [Wikipedia: Monoid](https://en.wikipedia.org/wiki/Monoid) â€” The structure string concatenation forms
- [Wikipedia: Abelian Group](https://en.wikipedia.org/wiki/Abelian_group) â€” The structure "addition" forms

### Historical Context

- **Ã‰variste Galois** (1811-1832) â€” Founder of group theory, died in a duel at age 20
- **Niels Henrik Abel** (1802-1829) â€” "Abelian" groups are named after him
- **Emmy Noether** (1882-1935) â€” Revolutionized abstract algebra and its connection to physics

### Connection to Programming

- [Haskell Typeclassopedia](https://wiki.haskell.org/Typeclassopedia) â€” How algebraic structures appear in functional programming
- Monoids and Semigroups are fundamental in Haskell, Scala, and Rust for combining data

</LectureResources>

