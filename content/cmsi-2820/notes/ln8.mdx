import { DisplayMath, InlineMath } from "@/components/math"
import {
  LectureNotes,
  LectureResources,
} from "@/components/lecture-sections"
import { QuestionBox } from "@/components/question-box"
import { DefinitionBox } from "@/components/interactive-example"
import { GraphVisualization } from "@/components/graph-visualization"

## Today's Agenda

We begin a new chapter of the course: **Collections**. Today we start with the second most fundamental collection of all â€” the **tuple**.

- **Introducing Tuples** â€” Ordered groupings of familiar items
- **Expressive Power** â€” Programs as tuples, objects as tuples
- **Formal Definition** â€” n-ary sequences and positional equality
- **Tuples vs Python** â€” Lists, tuples, and generators
- **Tuple Operations** â€” Indexing and concatenation
- **Tuple Types** â€” Product types and Cartesian notation
- **Pattern Matching** â€” Destructuring tuple structure
- **Named Tuples** â€” From positions to names
- **Tuples as Relations** â€” A preview of what's ahead
- **GÃ¶del Numbering** â€” Encoding tuples in history

---

## Introducing Tuples

Up to this point, every value we've worked with has been a single thing: a number, a boolean, a string, an operator. But mathematics (and programming!) constantly needs to talk about **groups of things in a specific order**.

Enter the **tuple** â€” an ordered collection of items.

The simplest tuple is a **pair**:

<DisplayMath formula="(1, 2)" />

But tuples can hold **anything** we've seen so far â€” numbers, booleans, strings, operators, logical atoms, and even other tuples:

| Tuple | Contents |
| :--- | :--- |
| $(1, 2)$ | Two natural numbers |
| $(\text{"hello"}, \top)$ | A string and a logical truth |
| $(+, 3)$ | An operator and a number |
| $((1, 2), (3, 4))$ | A tuple of tuples! |
| $(7, \text{"abc"}, \bot, 42)$ | A mix of everything |

Here's the crucial property that makes tuples special: **order matters**.

<DisplayMath formula="(1, 2) \neq (2, 1)" />

These contain the same items, but they're arranged differently â€” and that difference matters. A tuple isn't just a bag of items; it's items **in specific positions**.

> **ðŸ’¡ Key Insight:** Tuples give us the ability to express the fundamental nature of **order**. Before tuples, we could talk about individual values. Now we can talk about **structured arrangements** of values.

---

## Expressive Power: Programs as Tuples

Before we get into formal definitions, let's appreciate just how much expressive power tuples give us. The ability to put things in order unlocks some surprisingly deep ideas.

### Finite Sequences of Instructions

Think about what a program is at its core â€” a sequence of steps performed in order:

```
(open_file, read_data, process_data, write_output, close_file)
```

That's a tuple! A finite, ordered sequence of instructions. Every program you've ever written is, at some level, a tuple of operations.

This might seem like a trivial observation, but it has profound implications. If programs are tuples, then we can reason about programs using the same mathematical tools we use for tuples.

### Tuples as Conditionals

Here's something weirder. Consider a 3-tuple where the first position holds a boolean condition:

```
(is_raining, bring_umbrella, wear_sunglasses)
```

If we interpret this as "if the first element is true, do the second; otherwise, do the third" â€” we've just built an **if-statement** out of a tuple!

<DisplayMath formula="(\text{condition}, \text{consequence}, \text{alternative})" />

This is a pretty unusual way to think about conditionals. But it turns out we aren't the first to recognize this pattern...

### The Reveal: Clojure

The programming language **Clojure** (created by Rich Hickey in 2007) is built entirely around this idea. In Clojure, everything is a tuple (technically called a "list" in Lisp tradition, but structurally identical):

```clojure
(if (> x 10)
  (println "big")
  (println "small"))
```

That `if` expression is a 3-tuple: `(condition, consequence, alternative)` â€” exactly our pattern from above!

Even arithmetic is expressed as tuples:

```clojure
(+ 1 2 3 4)   ; => 10 (adds all arguments)
(* 2 (+ 3 4)) ; => 14 (multiplies 2 by the sum of 3 and 4)
```

Notice how programs in Clojure form a **tree structure** â€” tuples nested inside tuples:

<GraphVisualization
  nodes={[
    { id: "if", label: "if" },
    { id: "cond", label: "(> x 10)" },
    { id: "then", label: "println" },
    { id: "else", label: "println" },
    { id: "big", label: '"big"' },
    { id: "small", label: '"small"' },
  ]}
  edges={[
    { from: "if", to: "cond" },
    { from: "if", to: "then" },
    { from: "if", to: "else" },
    { from: "then", to: "big" },
    { from: "else", to: "small" },
  ]}
  height="280px"
/>

Every Clojure program is a tree of tuples. This makes programs easy to manipulate, transform, and reason about mathematically â€” because they're just data structures!

> **ðŸ’¡ Key Insight:** When your programs *are* tuples, the distinction between "code" and "data" dissolves. This is one of the most powerful ideas in computer science, and it's built on the humble tuple.

---

## Expressive Power: Tuples as Objects

Here's another direction tuples take us â€” toward something that looks a lot like **object-oriented programming**.

Consider modeling an email. We can break it down into ordered components using Python variables that store tuples:

```python
header_info = (from_addr, to_addr, cc, bcc, subject)
body = (text, attachments, signature)
share = (forward_list, reply_to)

email = (header_info, body, share)
```

Each variable holds a tuple, and the top-level `email` is a tuple of tuples. We've created an **ordered container for structured values** â€” without any classes, methods, or OOP machinery.

This is essentially what objects do: they group related data into a single structure with named positions. The only difference is that objects also attach *behavior* (methods) alongside the data.

> **ðŸ¤” But wait...** If tuples can model structured data like objects, and tuples can model programs like Clojure shows â€” does that mean tuples can model *everything*? We'll keep exploring this question throughout the Collections unit.

---

## Formal Definition: Tuples and Sequences

Now let's get precise. What exactly *is* a tuple?

<DefinitionBox term="Tuple (Finite Sequence)">

A **tuple** (or **finite sequence**) of size $n$ is an ordered collection of $n$ item instances:

<DisplayMath formula="(a_0, a_1, \ldots, a_n)" />

where each $a_i$ is called the **$i$-th component** (or element) of the tuple, and $n$ is called the **length** (or **arity**) of the tuple.

</DefinitionBox>

We refer to tuples by their size: a **pair** has 2 elements, a **triple** has 3, a **quadruple** has 4, and in general an **n-tuple** has $n$ elements.

### Positional Equality

When are two tuples equal? The answer is beautifully simple: check each position.

Let's start with pairs. Two pairs are equal exactly when their corresponding positions match:

<DisplayMath formula="(a_0, a_1) = (b_0, b_1) \;\equiv\; a_0 = b_0 \;\land\; a_1 = b_1" />

Notice the logical conjunction ($\land$) from our logic lectures! Equality of pairs is **logically equivalent** ($\equiv$) to a conjunction of positional equalities. We're using $\equiv$ here as **definitional equality** â€” the left side and the right side mean exactly the same thing. This is the same three-bar equivalence symbol we met in our logic lectures!

For triples, we just extend the pattern:

<DisplayMath formula="(a_0, a_1, a_2) = (b_0, b_1, b_2) \;\equiv\; a_0 = b_0 \;\land\; a_1 = b_1 \;\land\; a_2 = b_2" />

And in general, for n-tuples:

<DefinitionBox term="Tuple Equality">

Two tuples of the same length $n$ are equal exactly when all corresponding components are equal:

<DisplayMath formula="(a_0, \ldots, a_n) = (b_0, \ldots, b_n) \;\equiv\; \bigwedge_{i=0}^{n} a_i = b_i" />

Two tuples of **different lengths** are never equal.

</DefinitionBox>

This definition has a satisfying structure: tuple equality is just a conjunction of component-wise equalities. We're reusing the logical tools we already have!

**Examples:**

| Comparison | Equal? | Why |
| :--- | :--- | :--- |
| $(1, 2) = (1, 2)$ | âœ“ | $1 = 1 \;\land\; 2 = 2$ |
| $(1, 2) = (2, 1)$ | âœ— | $1 \neq 2$ (first position fails) |
| $(1, 2) = (1, 2, 3)$ | âœ— | Different lengths! |
| $(\top, 3) = (\top, 3)$ | âœ“ | $\top = \top \;\land\; 3 = 3$ |

---

## The Python Aside: Tuples, Lists, and Generators

Here's something that might surprise you: the formal mathematical tuple we just defined is **not** the same as Python's `tuple`.

The mathematical version is simply an ordered sequence of items. But Python's `tuple` has additional constraints:

| Property | Math Tuple | Python `tuple` | Python `list` |
| :--- | :--- | :--- | :--- |
| Ordered | âœ“ | âœ“ | âœ“ |
| Fixed length | Not required | âœ“ (immutable) | âœ— (mutable) |
| Immutable | Not specified | âœ“ | âœ— |
| Hashable | Not specified | âœ“ | âœ— |
| Can be infinite | âœ“ | âœ— | âœ— |

So Python's `tuple` is a **more restricted** version of the formal concept. It enforces immutability and fixed length â€” practical engineering decisions that help with performance and correctness, but not formal mathematical requirements.

And Python's `list`? It's *also* a representation of a formal tuple! Lists are ordered sequences â€” they just happen to be mutable and resizable. The distinction between `tuple` and `list` in Python is a **language design choice**, not a mathematical one.

> **ðŸ’¡ Key Insight:** Both Python tuples and Python lists are special cases of the formal mathematical tuple/sequence. The differences between them (mutability, hashability) exist for practical programming reasons, not for formally expressive ones.

What about infinite sequences? The mathematical definition allows them, but neither Python tuples nor lists can be infinite. The closest Python gets is a **generator**:

```python
def naturals():
    """An infinite sequence of natural numbers."""
    n = 0
    while True:
        yield n
        n += 1

# This "tuple" never ends!
gen = naturals()
next(gen)  # 0
next(gen)  # 1
next(gen)  # 2
# ... forever
```

So in Python, the formal mathematical tuple is really spread across three constructs: `tuple` (finite, immutable), `list` (finite, mutable), and `generator` (potentially infinite, lazy).

---

## Tuple Operations: Indexing

Now that we've defined tuples, let's define what we can *do* with them. The first operation is **indexing** â€” reaching into a tuple to extract a specific component.

<DefinitionBox term="Indexing Operator (â†“)">

The **indexing operator** $\downarrow$ takes a tuple and a natural number position, returning the component at that position:

<DisplayMath formula="(a_0, a_1, \ldots, a_n) \downarrow\; i = a_i \quad \text{where } 0 \leq i \leq n" />

</DefinitionBox>

The type judgment for this operator is:

<DisplayMath formula="\downarrow\; : (\text{Tuple}, \mathbb{N}) \to \text{Item}" />

The left operand must be a tuple, and the right operand must be a natural number within bounds.

**Examples:**

| Expression | Result | Reasoning |
| :--- | :--- | :--- |
| $(10, 20, 30) \downarrow\; 0$ | $10$ | First position |
| $(10, 20, 30) \downarrow\; 1$ | $20$ | Second position |
| $(10, 20, 30) \downarrow\; 2$ | $30$ | Third position |
| $(\top, \text{"hi"}) \downarrow\; 1$ | $\text{"hi"}$ | Second position |
| $(10, 20, 30) \downarrow\; 5$ | $\bot$ (undefined) | Out of bounds! |
| $7 \downarrow\; 1$ | $\bot$ (absurd) | 7 is not a tuple! |

Notice the last two rows: using the indexing operator incorrectly produces **absurdities**. Indexing out of bounds is undefined, and indexing a non-tuple is nonsensical. This is our type theory protecting us â€” the type judgment tells us exactly what inputs are valid.

### Python Comparison

Python uses bracket notation instead of the down-arrow, and counts from 0 instead of 1:

```python
t = (10, 20, 30)
t[0]   # 10 â€” Python counts from 0!
t[2]   # 30
t[5]   # IndexError â€” the type system catches this!
```

The `IndexError` is Python's way of saying "this expression is absurd" â€” exactly what our formal definition predicts.

---

## Tuple Operations: Concatenation

The second fundamental operation is **concatenation** â€” combining two tuples into one.

<DefinitionBox term="Concatenation Operator (Â·)">

The **concatenation operator** $\cdot$ takes two tuples and produces a new tuple containing all elements of the first followed by all elements of the second:

<DisplayMath formula="(a_1, \ldots, a_m) \cdot (b_1, \ldots, b_n) = (a_1, \ldots, a_m, b_1, \ldots, b_n)" />

</DefinitionBox>

The type judgment for concatenation is:

<DisplayMath formula="\cdot\; : (\text{Tuple}, \text{Tuple}) \to \text{Tuple}" />

This works between **any** two tuples, regardless of their types or lengths. A pair of integers can be concatenated with a triple of strings â€” no restrictions!

**Examples:**

| Expression | Result |
| :--- | :--- |
| $(1, 2) \cdot (3, 4)$ | $(1, 2, 3, 4)$ |
| $(\text{"a"}) \cdot (1, 2, 3)$ | $(\text{"a"}, 1, 2, 3)$ |
| $(1, 2) \cdot ()$ | $(1, 2)$ |

> **ðŸ”„ Connection to LN6:** Remember when we discovered that string concatenation is **associative** but **not commutative**? Tuple concatenation behaves the same way!
>
> - **Associative:** $((1,2) \cdot (3,)) \cdot (4,5) = (1,2) \cdot ((3,) \cdot (4,5)) = (1,2,3,4,5)$ âœ“
> - **Not commutative:** $(1,2) \cdot (3,4) = (1,2,3,4) \neq (3,4,1,2) = (3,4) \cdot (1,2)$ âœ—
>
> Tuple concatenation is a **monoid** â€” just like string concatenation!

### Python Comparison

Python uses the `+` operator for tuple concatenation:

```python
(1, 2) + (3, 4)       # (1, 2, 3, 4)
("a",) + (1, 2, 3)    # ("a", 1, 2, 3)
(1, 2) + ()            # (1, 2) â€” empty tuple is the identity!
```

---

## Tuple Types (Product Types)

So far, when we write a type judgment for a tuple, we might say:

<DisplayMath formula="(1, \text{'12'}, \text{dog}) : \text{Tuple}" />

This is **accurate** â€” it is indeed a tuple. But it's not very informative. We know more about this tuple than just "it's a tuple." We know what's in each position!

We can make the type **mirror the structure** of the value:

<DisplayMath formula="(1, \text{'12'}, \text{dog}) : (\text{Int}, \text{String}, \text{Obj})" />

The type itself looks like a tuple! Each position in the type corresponds to a position in the value, telling us exactly what type of item lives there.

<DefinitionBox term="Product Type (Tuple Type)">

A **product type** specifies the type of each component in a tuple:

<DisplayMath formula="(a_0, a_1, \ldots, a_n) : (A_0, A_1, \ldots, A_n)" />

where $a_i : A_i$ for each position $i$. This gives us **positional type information** â€” we know not just "it's a tuple" but exactly what's in each slot.

</DefinitionBox>

**Examples:**

| Value | Imprecise Type | Precise Product Type |
| :--- | :--- | :--- |
| $(1, 2)$ | Tuple | $(\mathbb{N}, \mathbb{N})$ |
| $(\top, \text{"hi"})$ | Tuple | $(\text{Bool}, \text{String})$ |
| $(3, \text{"abc"}, \bot)$ | Tuple | $(\mathbb{N}, \text{String}, \text{Bool})$ |
| $((1, 2), \text{"x"})$ | Tuple | $((\mathbb{N}, \mathbb{N}), \text{String})$ |

Notice the last row â€” a tuple containing a tuple gets a **nested** product type. The type structure precisely mirrors the value structure.

### Cartesian Product Notation

For historical reasons, product types can also be written using a multiplication-like notation:

<DisplayMath formula="(\mathbb{N}, \text{String}, \text{Bool}) \;\;\equiv\;\; \mathbb{N} \times \text{String} \times \text{Bool}" />

This is called the **Cartesian product** notation (named after RenÃ© Descartes). We'll investigate this multiplication operator more deeply when we study sets â€” for now, just know it's an alternative way to write the same type.

> **ðŸ“Œ Key Insight:** Product types make our type system significantly more powerful. Instead of just knowing "this is a tuple," we know exactly what type of data lives in each position. This precision is what makes type checking so useful!

### Operators Are Tuples in Disguise

Now here's a revelation. Look at the type judgment for addition that we've been writing since LN6:

<DisplayMath formula="+ : (\mathbb{N}, \mathbb{N}) \to \mathbb{N}" />

See the left side of the arrow? That's a **product type** â€” a tuple type! The operator's inputs are described as an ordered grouping of types. So what is this type judgment really saying?

<DisplayMath formula="+ : (\mathbb{N}, \mathbb{N}) \to \mathbb{N}" />

reads as: "given a tuple of type $(\mathbb{N}, \mathbb{N})$, addition **implies** (produces) a value of type $\mathbb{N}$."

The arrow $\to$ is **logical implication** applied to types! An operator is nothing more than:

1. A **tuple of input types** (the product type on the left)
2. An **implication arrow** (if you give me these inputs, I'll give you this output)
3. An **output type** (the result)

Let's revisit some operators we've seen through this lens:

| Operator | Type Judgment | Reading |
| :--- | :--- | :--- |
| Addition | $+ : (\mathbb{N}, \mathbb{N}) \to \mathbb{N}$ | "A pair of naturals implies a natural" |
| Conjunction | $\land : (\text{Bool}, \text{Bool}) \to \text{Bool}$ | "A pair of booleans implies a boolean" |
| Negation | $\lnot : (\text{Bool}) \to \text{Bool}$ | "A single boolean implies a boolean" |
| Indexing | $\downarrow : (\text{Tuple}, \mathbb{N}) \to \text{Item}$ | "A tuple-and-natural pair implies an item" |

Every operator we've ever written follows this pattern: **a product type implies an output type**. Tuples aren't just data â€” they're the hidden structure inside every operator's type signature.

> **ðŸ¤¯ Mind-Blown Moment:** The type judgment notation we've been using all semester is secretly built on tuples and implication. The arrow $\to$ is the same logical implication from our logic lectures, and the input side is the same product type we just defined. Tuples are woven into the very fabric of how we describe operations!

---

## Pattern Matching and Destructuring

If tuple types tell us the structure of a tuple, we should be able to use that structure to **decompose** a tuple back into its parts. This is called **destructuring** (or **pattern matching**).

Think of it as the **inverse of construction**:

- **Construction:** combine parts into a tuple â†’ $(a, b, c)$
- **Destructuring:** extract parts from a tuple â†’ $a, b, c$

<DefinitionBox term="Destructuring (Pattern Matching)">

Given a tuple $t : (A, B, C)$, **destructuring** extracts the individual components:

<DisplayMath formula="t = (a, b, c) \implies a : A,\; b : B,\; c : C" />

The type of each extracted component is determined by the product type.

</DefinitionBox>

### Python Unpacking

Python supports destructuring natively through **tuple unpacking**:

```python
# Basic unpacking
point = (3, 7)
x, y = point       # x = 3, y = 7

# Works with any tuple size
email = ("alice@lmu.edu", "Hello!", True)
sender, body, is_read = email
# sender = "alice@lmu.edu", body = "Hello!", is_read = True

# Even nested!
data = ((1, 2), "label")
(a, b), name = data  # a = 1, b = 2, name = "label"
```

Notice how the left side of the `=` mirrors the **structure** of the tuple on the right. The variable names act as placeholders that "catch" the values at each position.

### It Works on Lists Too!

Since lists are also sequences (remember our Python aside?), destructuring works on them identically:

```python
# List unpacking â€” same syntax!
coords = [10, 20, 30]
x, y, z = coords    # x = 10, y = 20, z = 30

# The star operator captures "the rest" into a list
first, *rest = [1, 2, 3, 4, 5]
# first = 1, rest = [2, 3, 4, 5]

head, *middle, tail = [10, 20, 30, 40, 50]
# head = 10, middle = [20, 30, 40], tail = 50
```

The `*rest` syntax is Python's way of saying "collect whatever remaining positions exist into a new list." This is especially useful when you know the first or last few positions but the tuple could be any length.

### Destructuring in For Loops

One of the most common (and readable!) uses of destructuring is inside **for loops**. When you iterate over a collection of tuples, you can unpack each one directly in the loop header:

```python
# Iterating over pairs
students = [("Alice", 95), ("Bob", 87), ("Carol", 92)]

for name, score in students:
    print(f"{name} scored {score}")
# Alice scored 95
# Bob scored 87
# Carol scored 92
```

Compare that to the version *without* destructuring:

```python
# Without destructuring â€” harder to read!
for student in students:
    print(f"{student[0]} scored {student[1]}")
```

The destructured version is clearer because the variable names (`name`, `score`) tell us what each position means. This pattern shows up everywhere:

```python
# enumerate() gives (index, value) pairs
colors = ["red", "green", "blue"]
for i, color in enumerate(colors):
    print(f"{i}: {color}")

# dict.items() gives (key, value) pairs
grades = {"Alice": "A+", "Bob": "B", "Carol": "A"}
for student, grade in grades.items():
    print(f"{student}: {grade}")

# zip() combines sequences into tuples
names = ["Alice", "Bob"]
scores = [95, 87]
for name, score in zip(names, scores):
    print(f"{name}: {score}")
```

Every one of these patterns â€” `enumerate()`, `dict.items()`, `zip()` â€” produces tuples, and destructuring makes working with them natural and readable.

### Clojure Destructuring

Remember Clojure from earlier? It supports destructuring too:

```clojure
(let [[x y] [3 7]]
  (+ x y))  ; => 10
```

The pattern `[x y]` matches against the structure of `[3 7]`, binding `x = 3` and `y = 7`.

> **ðŸ’¡ Key Insight:** Destructuring is one of the most practical consequences of tuple types. Because the type tells us the exact structure, we can safely decompose tuples without guessing. This is a technique you'll use **constantly** in Python â€” in for loops, function returns, and variable assignments â€” and it's foundational in functional programming.

---

## Named Tuples and Records

Positional tuples are powerful, but they have a practical weakness: **positions are hard to remember**.

Consider our email example from earlier:

```python
email = ("alice@lmu.edu", "bob@lmu.edu", "Hello!", True)
```

Quick â€” is `email[2]` the subject or the body? Is `email[3]` the read status or the CC list? With plain tuples, you have to memorize what each position means.

The natural evolution is to attach **names** to positions.

### Python's NamedTuple

Python provides `NamedTuple` â€” a tuple where each position has a name:

```python
from typing import NamedTuple

class Email(NamedTuple):
    sender: str
    recipient: str
    body: str
    is_read: bool

msg = Email("alice@lmu.edu", "bob@lmu.edu", "Hello!", False)

msg.sender    # "alice@lmu.edu" â€” access by name!
msg.body      # "Hello!"
msg[0]        # "alice@lmu.edu" â€” still a tuple underneath!
msg[2]        # "Hello!" â€” positional access still works!
```

The key insight: `msg.sender` and `msg[0]` return the same value. Named tuples are **still tuples** â€” they just give human-readable labels to each position.

### From Tuples to Classes

This bridge goes even further. Python's `dataclass` is essentially a named tuple with extra features:

```python
from dataclasses import dataclass

@dataclass
class Email:
    sender: str
    recipient: str
    body: str
    is_read: bool
```

And a regular Python class with `__init__`? Also a named tuple â€” but with methods (behavior) attached alongside the data.

This gives us a formal **math-to-code pipeline**:

```
Tuple â†’ Product Type â†’ Named Tuple â†’ Record â†’ Class
```

Each step adds a layer of practical convenience on top of the same mathematical foundation. At the bottom, it's all just ordered, typed groupings of values.

> **ðŸ“Œ Key Insight:** Named tuples are the bridge between mathematical tuples and OOP objects. A class with fields is essentially a named tuple with methods attached! Understanding tuples means understanding the core of how structured data works in every programming language.

---

## Tuples as Relations (Forward-Looking)

Before we close, let's peek at where tuples are taking us next.

Pairs of items naturally express **relationships**:

| Pair | Interpretation |
| :--- | :--- |
| (Alice, A+) | "Alice earned an A+" |
| (LA, NYC) | "LA connects to NYC" |
| ("name", "Alice") | "the key 'name' maps to 'Alice'" |
| (3, 9) | "3 is related to 9" (e.g., $3^2 = 9$) |

A **collection** of such pairs forms a **relation** â€” a concept we'll explore deeply in a few lectures. Relations are the foundation of:

- **Databases** â€” Every row in a table is a tuple, and tables are collections of tuples
- **Graphs** â€” Edges are pairs $(u, v)$ connecting two nodes
- **Dictionaries** â€” Python's `dict.items()` returns a collection of key-value pairs

```python
# A relation expressed as pairs!
grades = {
    "Alice": "A+",
    "Bob": "B",
    "Carol": "A",
}

# dict.items() gives us the underlying pairs
list(grades.items())
# [("Alice", "A+"), ("Bob", "B"), ("Carol", "A")]
```

This is just a teaser â€” we'll build the full formal machinery for relations soon. But the key takeaway is that **tuples are the building blocks of relational thinking**.

---

## GÃ¶del Numbering: Tuples Hidden in Numbers

Let's end with a historical surprise that ties together tuples and the number theory from our previous lectures.

In the 1930s, mathematician **Kurt GÃ¶del** discovered something remarkable: you can encode **any tuple of natural numbers as a single natural number**.

The trick? Use **prime factorization** â€” the very concept we explored in LN7!

### The Encoding

Assign each position in the tuple to a prime number (in order), and raise that prime to the power of the tuple's value at that position:

<DisplayMath formula="\langle a_1, a_2, \ldots, a_n \rangle = 2^{a_1} \times 3^{a_2} \times 5^{a_3} \times \cdots \times p_n^{a_n}" />

where $p_n$ is the $n$-th prime number.

### Example

Let's encode the tuple $(3, 1, 2)$:

<DisplayMath formula="\langle 3, 1, 2 \rangle = 2^3 \times 3^1 \times 5^2 = 8 \times 3 \times 25 = 600" />

The number **600** uniquely represents the tuple $(3, 1, 2)$. No other tuple produces 600, and 600 decodes to no other tuple.

<QuestionBox>

Why does this encoding work? Why can't two different tuples produce the same number?

Because of the **Fundamental Theorem of Arithmetic** from LN7! Every positive integer has a **unique** prime factorization. Since each position in the tuple maps to a distinct prime base, the exponents are uniquely determined by the number. Decoding is simply factoring the number and reading off the exponents.

</QuestionBox>

### Python Implementation

```python
primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

def godel_encode(tup):
    """Encode a tuple of naturals as a single number."""
    result = 1
    for i, val in enumerate(tup):
        result *= primes[i] ** val
    return result

def godel_decode(n, length):
    """Decode a GÃ¶del number back into a tuple."""
    result = []
    for i in range(length):
        count = 0
        while n % primes[i] == 0:
            n //= primes[i]
            count += 1
        result.append(count)
    return tuple(result)

godel_encode((3, 1, 2))    # => 600
godel_decode(600, 3)        # => (3, 1, 2)

godel_encode((0, 0, 0, 1)) # => 7  (only the 4th prime contributes)
godel_decode(7, 4)          # => (0, 0, 0, 1)
```

### Why This Matters

GÃ¶del didn't invent this encoding just for fun. He used it to prove his famous **Incompleteness Theorems** â€” one of the most important results in the history of mathematics. By encoding mathematical proofs as numbers (via tuples), GÃ¶del showed that any sufficiently powerful mathematical system contains true statements that *cannot be proven within that system*.

The connection to our course is profound: tuples are so fundamental that an entire number can secretly *be* a tuple. Order and structure are inescapable â€” even a single natural number can contain a complete sequence hiding within its prime factorization.

> **ðŸŒŸ Big Picture:** We started this lecture by showing that tuples can represent programs (Clojure) and objects (email). Now we've shown that tuples can be hidden inside *numbers*. The humble tuple is one of the most versatile structures in all of mathematics.

---

<LectureNotes>

**Key Definitions:**

- **Tuple (Finite Sequence)** â€” An ordered collection $(a_1, a_2, \ldots, a_n)$ of $n$ item instances
- **Tuple Equality** â€” $(a_0, \ldots, a_n) = (b_0, \ldots, b_n) \equiv \bigwedge_{i=0}^{n} a_i = b_i$
- **Indexing Operator** ($\downarrow$) â€” Extracts the component at position $i$: $(a_1, \ldots, a_n) \downarrow\; i = a_i$
- **Concatenation Operator** ($\cdot$) â€” Joins two tuples end-to-end
- **Product Type** â€” A type $(A_1, A_2, \ldots, A_n)$ specifying the type of each position
- **Destructuring** â€” Extracting individual components from a tuple using its type structure
- **Named Tuple** â€” A tuple where each position has a human-readable name
- **GÃ¶del Number** â€” A single natural number encoding a tuple via prime factorization

**Key Operators:**

| Operator | Notation | Type Signature |
| :--- | :--- | :--- |
| Indexing | $t \downarrow\; i$ | $(\text{Tuple}, \mathbb{N}) \to \text{Item}$ |
| Concatenation | $s \cdot t$ | $(\text{Tuple}, \text{Tuple}) \to \text{Tuple}$ |

**Tuples in Python:**

| Formal Concept | Python Construct | Key Difference |
| :--- | :--- | :--- |
| Finite tuple | `tuple` | Immutable, fixed length |
| Finite sequence | `list` | Mutable, resizable |
| Infinite sequence | `generator` | Lazy, potentially infinite |

**The Math-to-Code Pipeline:**

Tuple â†’ Product Type â†’ Named Tuple â†’ Record â†’ Class

</LectureNotes>

<LectureResources>

### Recommended Viewing

- [Computerphile: "GÃ¶del's Incompleteness Theorem"](https://www.youtube.com/watch?v=O4ndIDcDSGc) â€” How GÃ¶del numbering enabled the most famous proof in mathematics
- [Fireship: "Clojure in 100 Seconds"](https://www.youtube.com/watch?v=ciGyHkDuPAE) â€” Quick tour of the tuple-based language

### Further Reading

- [Wikipedia: Tuple](https://en.wikipedia.org/wiki/Tuple) â€” Formal mathematical treatment
- [Wikipedia: Sequence](https://en.wikipedia.org/wiki/Sequence) â€” The broader concept of ordered collections
- [Wikipedia: Product Type](https://en.wikipedia.org/wiki/Product_type) â€” Tuple types in type theory
- [Wikipedia: GÃ¶del Numbering](https://en.wikipedia.org/wiki/G%C3%B6del_numbering) â€” Encoding sequences as numbers

### Historical Context

- **RenÃ© Descartes** (1596-1650) â€” The Cartesian product (and Cartesian coordinates) are named after him
- **Kurt GÃ¶del** (1906-1978) â€” Used tuple encodings to prove the Incompleteness Theorems in 1931
- **Rich Hickey** (1961-present) â€” Created Clojure in 2007, bringing tuple-based programming to the JVM

### Connection to Programming

- Python's `tuple`, `list`, and `generator` all implement the formal concept of sequences
- `NamedTuple` and `dataclass` bridge tuples to OOP-style records
- Pattern matching / destructuring (`x, y = point`) is standard in Python, JavaScript, Rust, and most modern languages
- Clojure, Lisp, and Scheme treat programs as tuple-like data structures (homoiconicity)

</LectureResources>
